{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/js/emoji-canvas.js","src/js/emojify.js","src/js/get-user-media.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"emojify.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * A module that takes a clm tracker object and uses it to draw an emoji face\r\n * using p5.  The canvas has a debug mode that can be toggled on/off by pressing\r\n * the \"f\" key.\r\n * @module emoji-canvas\r\n */\r\n\r\nmodule.exports = EmojiCanvas;\r\n\r\nfunction EmojiCanvas(ctracker) {\r\n    this.ctracker = ctracker;\r\n    this.debugModeEnabled = false;\r\n};\r\n\r\nEmojiCanvas.prototype.start = function(width, height, parentElement) {\r\n    // Using p5 in instance mode:\r\n    //  https://github.com/processing/p5.js/wiki/Instantiation-Cases\r\n    // This keeps everything from ending up in the global scope.\r\n    var sketch = function (p) {\r\n        // Store p5 instance, so that not all methods have to be based it \r\n        // directly\r\n        this.p = p;\r\n        // Bind a context and some parameters to the p5 functions, so that when\r\n        // they are called by the p5 event loop, they have the info we want.\r\n        p.setup = this._setup.bind(this, p, width, height);\r\n        p.draw = this._draw.bind(this, p);\r\n        p.keyPressed = this._keyPressed.bind(this, p);\r\n    }.bind(this);\r\n    new p5(sketch, parentElement);\r\n};\r\n\r\nEmojiCanvas.prototype.clear = function() {\r\n    if (this.p) this.p.clear();\r\n};\r\n\r\nEmojiCanvas.prototype._setup = function(p, width, height) {\r\n    var canvas = p.createCanvas(width, height);\r\n    p.textSize(32); // Set the \"default\" text size for the canvas once\r\n};\r\n\r\nEmojiCanvas.prototype._draw = function(p) {\r\n    p.clear();\r\n    // Get the array of face points from tracker, returns false if no face is \r\n    // detected\r\n    var facePoints = this.ctracker.getCurrentPosition();\r\n    if (facePoints) {\r\n        this._drawEmoji(p, facePoints);\r\n        if (this.debugModeEnabled) {\r\n            // The score is a value between 0 and 1 that describes how well the\r\n            // \"detected\" face matches the tracker's face model \r\n            var score = this.ctracker.getScore();\r\n            this._drawDebug(p, facePoints, score);\r\n        }\r\n    }\r\n};\r\n\r\nEmojiCanvas.prototype._keyPressed = function(p) {\r\n    var lowerKey = p.key.toLowerCase();\r\n    if (lowerKey === \"f\") {\r\n        this.debugModeEnabled = !this.debugModeEnabled\r\n    };\r\n};\r\n\r\nEmojiCanvas.prototype._drawDebug = function(p, facePoints, score) {\r\n    p.fill(255);\r\n    p.noStroke();\r\n    p.text(\"Face Match: \" + p.round(score * 100) + \"%\", 10, 40);\r\n    p.fill(255);\r\n    p.stroke(0);\r\n    p.strokeWeight(1);\r\n    for (var i = 0; i < facePoints.length; i += 1) {\r\n        var point = facePoints[i];\r\n        p.ellipse(point[0], point[1], 4, 4);\r\n    }\r\n};\r\n\r\nEmojiCanvas.prototype._drawEmoji = function (p, facePoints) {\r\n    // clmtrackr has a reference diagram that shows what the array of facePoints\r\n    // correspond to in terms of the face model:\r\n    //  http://auduno.github.io/clmtrackr/docs/reference.html\r\n    // Calculate the face diameter.  This is used to size the other face \r\n    // components.\r\n    var nose = facePoints[41];\r\n    var chin = facePoints[7];\r\n    var chinDist = facePosDist(nose, chin);\r\n    var faceDiameter = 2 * chinDist;\r\n    // Draw the components\r\n    this._drawHead(p, facePoints, faceDiameter);\r\n    this._drawEyes(p, facePoints, faceDiameter);\r\n    this._drawMouth(p, facePoints, faceDiameter);\r\n};\r\n\r\nEmojiCanvas.prototype._drawHead = function(p, facePoints, faceDiameter) {\r\n    var center = facePoints[41];\r\n    p.fill(\"#ffdd67\");\r\n    p.noStroke();\r\n    p.ellipse(center[0], center[1], faceDiameter, faceDiameter);\r\n};\r\n\r\nEmojiCanvas.prototype._drawEyes = function(p, facePoints, faceDiameter) {\r\n    var leftPos = facePoints[27];\r\n    var rightPos = facePoints[32];\r\n    var eyeDiameter = faceDiameter * 0.3;\r\n    var irisDiameter = eyeDiameter * 0.5;\r\n    p.fill(255);\r\n    p.noStroke();\r\n    p.ellipse(leftPos[0], leftPos[1], eyeDiameter, eyeDiameter);\r\n    p.ellipse(rightPos[0], rightPos[1], eyeDiameter, eyeDiameter);\r\n    p.fill(\"#664e27\");\r\n    p.ellipse(leftPos[0], leftPos[1], irisDiameter, irisDiameter);\r\n    p.ellipse(rightPos[0], rightPos[1], irisDiameter, irisDiameter);\r\n};\r\n\r\nEmojiCanvas.prototype._drawMouth = function(p, facePoints, faceDiameter) {\r\n    var mouthLeft = facePoints[44];\r\n    var mouthRight = facePoints[50];\r\n    var mouthTop = facePoints[47];\r\n    var upperLipBottom = facePoints[60];\r\n    var lowerLipTop = facePoints[57];\r\n    var mouthSize = faceDiameter * 0.5;\r\n    var mouthWidth = facePosDist(mouthLeft, mouthRight);\r\n    var mouthCenter = facePosAve(mouthLeft, mouthRight);\r\n    var mouthAngle = p.atan2(mouthRight[1] - mouthLeft[1],\r\n                             mouthRight[0] - mouthLeft[0]);\r\n    var lipDist = facePosDist(upperLipBottom, lowerLipTop);\r\n    var normalizedLipDist = lipDist / mouthWidth;\r\n    var isOpen = (normalizedLipDist > 0.2);\r\n    var eyeDiameter = faceDiameter * 0.3;\r\n    var irisDiameter = eyeDiameter * 0.5;    \r\n    // Draw the mouth\r\n    if (!isOpen) {\r\n        // Draw a straight line mouth\r\n        p.stroke(\"#664e27\");\r\n        p.noFill();\r\n        p.strokeWeight(10);  \r\n        p.line(mouthLeft[0], mouthLeft[1], mouthRight[0], mouthRight[1]);\r\n    }\r\n    else {        \r\n        // Draw a half-circle mouth\r\n        p.fill(\"#664e27\");\r\n        p.noStroke();\r\n        p.push();\r\n        p.translate(mouthTop[0], mouthTop[1]);\r\n        p.rotate(mouthAngle);\r\n        p.arc(0, 0, mouthSize, mouthSize, 0, p.PI, p.CHORD);\r\n        p.pop();\r\n    }\r\n};\r\n\r\n// Helper functions that are private to this module\r\n\r\nfunction facePosDist(pos1, pos2) {\r\n    var dx = pos2[0] - pos1[0];\r\n    var dy = pos2[1] - pos1[1];\r\n    return Math.sqrt((dx * dx) + (dy * dy));\r\n}\r\n\r\nfunction facePosAve(pos1, pos2) {\r\n    var ax = (pos1[0] + pos2[0]) / 2;\r\n    var ay = (pos1[1] + pos2[1]) / 2;\r\n    return [ax, ay];\r\n}","// Modules\r\nvar EmojiCanvas = require(\"./emoji-canvas.js\");\r\nvar crossBrowserGetUserMedia = require(\"./get-user-media.js\");\r\n\r\n// Global flags for keeping track of when the video stream has started\r\nvar hasStreamStarted = false;\r\n\r\n// Get & cache DOM elements\r\nvar startButton = document.getElementById(\"start-button\");\r\nvar stopButton = document.getElementById(\"stop-button\");\r\nvar trackerContainer = document.getElementById(\"tracker-container\");\r\nvar video = document.getElementById(\"webcam-stream\");\r\n\r\n// Set up a tracker\r\nvar ctracker = new clm.tracker({ useWebGL: true });\r\nctracker.init(pModel);\r\n\r\n// Set up the canvas that will draw the emoji face\r\nvar emojiCanvas = new EmojiCanvas(ctracker);\r\n\r\n// When the start button is pressed, make sure the webcam feed has loaded before\r\n// starting the clm tracker\r\nstartButton.addEventListener(\"click\", function (event) {\r\n    if (hasStreamStarted) {        \r\n        ctracker.start(video);\r\n    }\r\n});\r\n\r\n// When the stop button is pressed, stop & reset everything so that no emojis\r\n// are drawn\r\nstopButton.addEventListener(\"click\", function (event) {\r\n    ctracker.reset();      \r\n    ctracker.stop();\r\n    emojiCanvas.clear();\r\n});\r\n\r\n// Get the web cam feed\r\nif (!crossBrowserGetUserMedia) {\r\n    displayError(\"Unfortunately, your browser doesn't support webcam feeds \" +\r\n                 \"in the browser :(\")\r\n}\r\nelse {\r\n    // Request a video stream\r\n    // We could also make a request for a specific resolution, if we wanted\r\n    var constraints = {\r\n        audio: false,\r\n        video: true\r\n    };\r\n    crossBrowserGetUserMedia(constraints, handleStream, handleError);\r\n}\r\n\r\nfunction handleStream(mediaStream) {\r\n    // Pipe webcam stream to video element\r\n    video.src = window.URL.createObjectURL(mediaStream);\r\n    video.play();\r\n    video.addEventListener(\"loadedmetadata\", function () {\r\n        // When this event fires, the video element will have figured out its\r\n        // attributes (including width & height of the stream)\r\n        // Give the video a width & height attribute, because that's what \r\n        // the clm tracker will eventually need.\r\n        hasStreamStarted = true;\r\n        video.width = video.videoWidth;\r\n        video.height = video.videoHeight;\r\n        // Create the emoji canvas and append it to the trackerContainer DOM\r\n        // element\r\n        emojiCanvas.start(video.width, video.height, trackerContainer);\r\n    });\r\n}\r\n\r\nfunction handleError(error) {\r\n    console.log(\"Error: %s\", error);\r\n    if (error.name.toLowerCase() === \"permissiondeniederror\") {\r\n        displayError(\"This app needs permission to use your webcam.\");\r\n    }        \r\n    else {\r\n        displayError(\"Error getting webcam feed!\");\r\n    }\r\n}\r\n\r\nfunction displayError(message) {\r\n    var errorMessage = document.getElementById(\"error-message\");\r\n    errorMessage.textContent = message;\r\n    errorMessage.style.display = \"block\";\r\n}","/**\r\n * A module that returns a function (or null) that can get user media in a cross\r\n * browser compatible way.\r\n * @module get-user-media\r\n */\r\n\r\nmodule.exports = (function getCrossBrowserUserMedia() {\r\n\tif (!window.navigator) return null;\r\n    // Unfortunately, we're at a point where we still have to use vendor \r\n    // prefixes to get user media.\r\n    var _getUserMedia = navigator.getUserMedia ||       // No prefix\r\n                        navigator.webkitGetUserMedia || // Chrome/Opera\r\n                        navigator.mozGetUserMedia ||    // Mozilla\r\n                        navigator.msGetUserMedia;       // IE\r\n    if (!_getUserMedia) return null;\r\n    // If we have navigator and one of the getUserMedia prefixes, then return\r\n    // a function with the proper context bound to it (i.e. navigator).  If you\r\n    // call getUserMedia without the navigator context, it will error out.\r\n    return _getUserMedia.bind(navigator);\r\n})();"]}